# this doesn't use odeint. this uses "adaptive stepping" 
# same idea as before, just making results more precise (still not ligo/virgo level)
# uses adaptive Runge-Kutta method by Dormand and Prince (check readme)
# uses scipy’s integrate.ode module (method = “dopri5”)
#this is unfamiliar territory, so might contain significant errors

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import ode

# constants
m1 = m2 = 5
m = m1 + m2
mu = m1 * m2 / m

# System of ODEs
def F(v):
    return (32 / 5) * (mu / m)**2 * v**10

def E_prime(v):
    return -mu * v

def system(t, y):
    v, phi = y
    dvdt = -F(v) / E_prime(v)
    dphidt = v**3 / m
    return [dvdt, dphidt]

# Initial conditions
v0 = 0.3
phi0 = 0.0
y0 = [v0, phi0]
t0 = 0
t_max = 100
dt = 0.1

# Set up solver
solver = ode(system)
solver.set_integrator('dopri5')
solver.set_initial_value(y0, t0)

# Storage
t_vals = []
v_vals = []
phi_vals = []

while solver.successful() and solver.t < t_max:
    solver.integrate(solver.t + dt)
    t_vals.append(solver.t)
    v_vals.append(solver.y[0])
    phi_vals.append(solver.y[1])

# Convert to arrays
t_vals = np.array(t_vals)
v_vals = np.array(v_vals)
phi_vals = np.array(phi_vals)

# Gravitational waves
h_plus = 4 * (mu / m) * v_vals**2 * np.cos(phi_vals)
h_cross = 4 * (mu / m) * v_vals**2 * np.sin(phi_vals)

# Plot
plt.plot(t_vals, h_plus, label="h+ (adaptive)", color='green')
plt.plot(t_vals, h_cross, label="h× (adaptive)", color='red')
plt.title("Part 3: GW Polarizations (Dormand-Prince RK45)")
plt.xlabel("Time")
plt.ylabel("Strain")
plt.legend()
plt.grid()
plt.show()
